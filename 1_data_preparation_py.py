# -*- coding: utf-8 -*-
"""1_data_preparation.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11u-QeO4vjuicxtTkgsDVqka_6Wad-VHn
"""

import ee
import os
import pandas as pd
import cdsapi
import zipfile
import shutil
import xarray as xr
from tqdm import tqdm

# --- НАСТРОЙКИ ---
# Укажите ваш проект GEE
GEE_PROJECT = 'Your_GEE'

# Папка для сохранения итоговых данных
OUTPUT_DATA_DIR = 'data'
START_PERIOD_FILE = os.path.join(OUTPUT_DATA_DIR, 'final_start.csv')
END_PERIOD_FILE = os.path.join(OUTPUT_DATA_DIR, 'final_end.csv')

# --- Настройки для сбора данных по НАЧАЛУ периода ---
START_PERIOD_CONFIG = {
    'dates': ['2020-04-01', '2020-05-30', '2021-04-01', '2021-05-30', '2022-04-01', '2022-05-30'],
    'cutoff_date': '05-01', # Пороговая дата для разметки (месяц-день)
    'file_prefix': 'start_period'
}

# --- Настройки для сбора данных по КОНЦУ периода ---
END_PERIOD_CONFIG = {
    'dates': ['2020-09-15', '2020-10-30', '2021-09-15', '2021-10-30', '2022-09-15', '2022-10-30'],
    'cutoff_date': '10-12', # Пороговая дата для разметки (месяц-день)
    'file_prefix': 'end_period'
}

# Координаты для анализа (общие для обоих периодов)
COORDINATES = [
    (43.32926062568456, 131.69019339257446),
    (43.28720376071115, 131.6661747769596),
    (43.29283267327599, 131.65873272166493),
    (43.30515001686172, 131.62899160952983),
    (43.28912113135703, 131.58399349366854),
    (43.32893422826966, 131.51989125201234),
    (43.386239246940015, 131.43550891573577),
    (43.44079044950246, 131.31655858784072),
    (43.38805426668223, 131.34114358703778),
    (43.30571902816206, 131.3362753459364),
    (43.27277173973229, 131.36539625553633),
    (43.19892929155301, 131.29004095014346),
    (43.16873197035487, 131.3202932407039),
    (43.198844366634944, 131.22285698822282),
    (43.143857966203186, 131.5883830725989),
    (43.160085776052746, 131.58114048314744),
    (43.16386559293059, 131.5645384142828),
    (43.095180966216816, 131.54993749433675),
    (43.10896154025971, 131.4657991976505),
    (42.97036624769827, 131.3238914057048),
    (42.9474397207082, 131.2929918543746),
    (42.942741092983304, 131.27857065281938),
    (42.960952120608944, 131.2469934749618),
    (42.98010071862131, 131.2166927785777),
    (42.99878141458547, 131.20198104987773),
    (43.004006058890134, 131.180218417623),
    (43.01935864133869, 131.15640059661882),
    (43.03563994186749, 131.12074893245284),
    (43.00470408672718, 131.1216300343176),
    (42.978888277704264, 131.18369653907726),
    (42.96678236143308, 131.22511917495873),
    (42.9293170426007, 131.2871082364546),
    (42.89995789986464, 131.32527203976787),
    (42.87362778310852, 131.32325212871075),
    (42.78617422501246, 130.9521448423081),
    (42.78469523914138, 130.9625307004462),
    (42.79788559467508, 130.97354940032812),
    (42.78439974989895, 131.02318912504393),
    (42.739652902173944, 131.0475512568405),
    (42.722437846571886, 131.02447313761343),
    (42.70912116459622, 131.01332929756916),
    (42.655179230430406, 131.15237571539768),
    (42.66839561984622, 131.16884279791373),
    (42.67228944283504, 131.15653489749445),
    (42.680438745561034, 131.15234192872185),
    (42.68418286260106, 131.16620244915555),
    (42.69010710781293, 131.15486245207865),
    (42.69832504446386, 131.16422976215077),
    (42.701876750926665, 131.16860309783115),
    (42.70410020529092, 131.15205160793056),
    (42.75011051804148, 131.1580510973005),
    (42.761448090625365, 131.15422873882582),
    (42.77396637700183, 131.14494293017808),
    (42.78597680635486, 131.16643977850632),
    (42.7843645541549, 131.17195971581927),
    (42.79465405266338, 131.15217015853713),
    (42.795954396111, 131.12761116677794),
    (42.80419791798207, 131.10592337310072),
    (42.80443739934873, 131.10079479307407)
]

# --- Инициализация API ---
try:
    ee.Initialize(project=GEE_PROJECT)
except ee.EEException:
    ee.Authenticate()
    ee.Initialize(project=GEE_PROJECT)

cds_client = cdsapi.Client()

# --- Функции ---

def download_gee_data(coords, start_date, end_date):
    """Скачивает данные Sentinel-2 для списка координат."""
    all_points_data = []
    bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B11', 'B12']

    collection = (ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                  .filterDate(start_date, end_date)
                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 60)))

    for lat, lon in tqdm(coords, desc=f"Загрузка GEE {start_date}-{end_date}"):
        point = ee.Geometry.Point(lon, lat)

        def extract_pixel_values(image):
            # Извлекаем значения пикселей для точки
            data = image.select(bands).reduceRegion(
                reducer=ee.Reducer.mean(),
                geometry=point,
                scale=10
            ).getInfo()
            data['datetime_utc'] = image.date().format('YYYY-MM-dd HH:mm:ss')
            data['latitude'] = lat
            data['longitude'] = lon
            return data

        try:
            point_timeseries = collection.filterBounds(point).map(extract_pixel_values).getInfo()
            all_points_data.extend(point_timeseries)
        except Exception as e:
            print(f"Ошибка при обработке точки ({lat}, {lon}): {e}")

    return pd.DataFrame(all_points_data)

def enrich_with_weather_data(df):
    """Обогащает датафрейм данными о погоде из CDS."""
    df['date_only'] = pd.to_datetime(df['datetime_utc']).dt.strftime('%Y-%m-%d')
    unique_requests = df[['latitude', 'longitude', 'date_only']].drop_duplicates()

    era5_data = []
    for _, row in tqdm(unique_requests.iterrows(), total=len(unique_requests), desc="Загрузка погоды ERA5"):
        try:
            cds_client.retrieve(
                'reanalysis-era5-land',
                {
                    'variable': ['2m_temperature', 'forecast_albedo', 'surface_latent_heat_flux',
                                 'surface_net_solar_radiation', 'surface_net_thermal_radiation',
                                 'surface_sensible_heat_flux', 'surface_solar_radiation_downwards',
                                 'surface_thermal_radiation_downwards', 'total_evaporation',
                                 'leaf_area_index_high_vegetation', 'leaf_area_index_low_vegetation'],
                    'year': row['date_only'][:4],
                    'month': row['date_only'][5:7],
                    'day': row['date_only'][8:10],
                    'time': '02:00',
                    'area': [row['latitude'], row['longitude'], row['latitude'], row['longitude']],
                    'format': 'grib',
                },
                'download.grib')

            ds = xr.open_dataset('download.grib', engine='cfgrib')
            data_dict = {var: ds[var].values.item() for var in ds.data_vars}
            data_dict.update({'latitude': row['latitude'], 'longitude': row['longitude'], 'date_only': row['date_only']})
            era5_data.append(data_dict)
            os.remove('download.grib')
        except Exception as e:
            print(f"Не удалось получить данные о погоде для {row['date_only']} в точке {row['latitude']},{row['longitude']}: {e}")

    if not era5_data:
        print("Не удалось загрузить данные о погоде.")
        return df

    era5_df = pd.DataFrame(era5_data)
    # Переименование столбцов для соответствия вашим моделям
    column_mapping = {
        't2m': '2m_temperature', 'fal': 'forecast_albedo', 'slhf': 'surface_latent_heat_flux',
        'ssr': 'surface_net_solar_radiation', 'str': 'surface_net_thermal_radiation',
        'sshf': 'surface_sensible_heat_flux', 'ssrd': 'surface_solar_radiation_downwards',
        'strd': 'surface_thermal_radiation_downwards', 'e': 'total_evaporation',
        'lai_hv': 'leaf_area_index_high_vegetation', 'lai_lv': 'leaf_area_index_low_vegetation'
    }
    era5_df.rename(columns=column_mapping, inplace=True)

    return pd.merge(df, era5_df, on=['latitude', 'longitude', 'date_only'], how='left')


def label_data(group, cutoff_date_str):
    """Размечает данные для одной координаты."""
    group['datetime_utc'] = pd.to_datetime(group['datetime_utc'])
    group = group.sort_values('datetime_utc')

    year = group['datetime_utc'].dt.year.iloc[0]
    cutoff_date = pd.to_datetime(f"{year}-{cutoff_date_str}")

    group['Target'] = (group['datetime_utc'] >= cutoff_date).astype(int)

    first_one_indices = group[group['Target'] == 1].index
    if not first_one_indices.empty:
        first_one_index = first_one_indices[0]
        first_one_location = group.index.get_loc(first_one_index)
        return group.iloc[:first_one_location + 1]

    return group

def process_period(config, coords):
    """Полный пайплайн для одного периода (начало или конец)."""
    print(f"\n--- Обработка периода: {config['file_prefix']} ---")

    all_dfs = []
    # Цикл по парам дат (например, весна 2020, весна 2021 и т.д.)
    for i in range(0, len(config['dates']), 2):
        start_date = config['dates'][i]
        end_date = config['dates'][i+1]

        df = download_gee_data(coords, start_date, end_date)
        if not df.empty:
            all_dfs.append(df)

    if not all_dfs:
        print("Не удалось загрузить данные GEE. Процесс остановлен.")
        return pd.DataFrame()

    combined_df = pd.concat(all_dfs, ignore_index=True).dropna()

    print("Обогащение данными о погоде...")
    enriched_df = enrich_with_weather_data(combined_df)

    print("Разметка данных...")
    grouped = enriched_df.groupby(['latitude', 'longitude', enriched_df['datetime_utc'].dt.year])
    labeled_dfs = [label_data(group, config['cutoff_date']) for _, group in grouped]
    final_df = pd.concat(labeled_dfs, ignore_index=True)

    # Удаляем временные колонки
    final_df.drop(columns=['date_only', 'time'], inplace=True, errors='ignore')

    return final_df

# --- Основной скрипт ---
if __name__ == "__main__":
    if not os.path.exists(OUTPUT_DATA_DIR):
        os.makedirs(OUTPUT_DATA_DIR)

    # Обработка данных для НАЧАЛА вегетационного периода
    start_df = process_period(START_PERIOD_CONFIG, COORDINATES)
    if not start_df.empty:
        start_df.to_csv(START_PERIOD_FILE, index=False)
        print(f"\nИтоговый датасет для НАЧАЛА периода сохранен в: {START_PERIOD_FILE}")
        print(f"Размер: {start_df.shape}")

    # Обработка данных для КОНЦА вегетационного периода
    end_df = process_period(END_PERIOD_CONFIG, COORDINATES)
    if not end_df.empty:
        end_df.to_csv(END_PERIOD_FILE, index=False)
        print(f"\nИтоговый датасет для КОНЦА периода сохранен в: {END_PERIOD_FILE}")
        print(f"Размер: {end_df.shape}")

    print("\nПодготовка данных завершена.")