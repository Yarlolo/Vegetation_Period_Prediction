# -*- coding: utf-8 -*-
"""2_train_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yf6WCqbHBn0UrDqewA1FQztmVtZpEmro
"""

import pandas as pd
import numpy as np
import argparse
import joblib
import os
import matplotlib.pyplot as plt
import seaborn as sns

# Импорты из Scikit-learn и других библиотек
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score, roc_auc_score, confusion_matrix, roc_curve, auc
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from xgboost import XGBClassifier
from sklearn.neural_network import MLPClassifier

# --- Настройки ---
OUTPUT_MODEL_DIR = 'models'
DATA_DIR = 'data'
RANDOM_STATE = 42

# --- Функции ---

def load_and_prepare_data(period_type):
    """Загружает и подготавливает данные для обучения."""
    filename = os.path.join(DATA_DIR, f'final_{period_type}.csv')
    print(f"Загрузка данных из {filename}...")
    data = pd.read_csv(filename)

    # Расчет вегетационных индексов
    print("Расчет вегетационных индексов (NDVI, NDWI, EVI)...")
    data['NDVI'] = (data['B8'] - data['B4']) / (data['B8'] + data['B4'])
    data['NDWI'] = (data['B3'] - data['B8']) / (data['B3'] + data['B8'])
    data['EVI'] = 2.5 * (data['B8'] - data['B4']) / (data['B8'] + 6 * data['B4'] - 7.5 * data['B2'] + 1)

    # Создание временных признаков
    data['datetime'] = pd.to_datetime(data['datetime_utc'])
    data['year'] = data['datetime'].dt.year
    data['month'] = data['datetime'].dt.month
    data['day'] = data['datetime'].dt.day
    data['doy'] = data['datetime'].dt.dayofyear # День года

    # Заменяем бесконечные значения на NaN, чтобы импьютер мог их обработать
    data.replace([np.inf, -np.inf], np.nan, inplace=True)

    # Определение признаков (X) и цели (y)
    # ВАЖНО: Убираем все ненужные колонки, включая 'datetime_utc', которая вызывала ошибку
    drop_cols = ['Vegetation', 'datetime_utc', 'datetime', 'latitude', 'longitude']
    X = data.drop(columns=drop_cols)
    y = data['Vegetation']

    return X, y

def build_pipeline():
    """Создает пайплайн предобработки данных."""
    numeric_features = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B11', 'B12',
                        '2m_temperature', 'forecast_albedo', 'surface_latent_heat_flux',
                        'surface_net_solar_radiation', 'surface_net_thermal_radiation',
                        'surface_sensible_heat_flux', 'surface_solar_radiation_downwards',
                        'surface_thermal_radiation_downwards', 'total_evaporation',
                        'leaf_area_index_high_vegetation', 'leaf_area_index_low_vegetation',
                        'NDVI', 'NDWI', 'EVI', 'year', 'month', 'day', 'doy']

    numeric_transformer = Pipeline(steps=[
        ('imputer', SimpleImputer(strategy='median')),
        ('scaler', StandardScaler())
    ])

    preprocessor = ColumnTransformer(
        transformers=[('num', numeric_transformer, numeric_features)],
        remainder='drop'
    )
    return preprocessor

def train_and_evaluate(X, y, period_type):
    """Обучает, оценивает и сохраняет ансамблевую модель."""
    # Разделение данных
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=RANDOM_STATE, shuffle=True, stratify=y
    )
    print(f"Размер обучающей выборки: {X_train.shape[0]}, тестовой: {X_test.shape[0]}")

    # Создание пайплайна предобработки
    preprocessor = build_pipeline()

    # Определение моделей
    rf_pipeline = Pipeline([('preprocessor', preprocessor), ('classifier', RandomForestClassifier(n_estimators=100, random_state=RANDOM_STATE))])
    xgb_pipeline = Pipeline([('preprocessor', preprocessor), ('classifier', XGBClassifier(n_estimators=100, random_state=RANDOM_STATE))])
    mlp_pipeline = Pipeline([('preprocessor', preprocessor), ('classifier', MLPClassifier(hidden_layer_sizes=(64, 32), max_iter=200, random_state=RANDOM_STATE))]) # max_iter увеличен

    # Ансамбль
    voting_ensemble = VotingClassifier(
        estimators=[('rf', rf_pipeline), ('xgb', xgb_pipeline), ('mlp', mlp_pipeline)],
        voting='soft'
    )

    # Обучение
    print("Обучение ансамблевой модели...")
    voting_ensemble.fit(X_train, y_train)

    # Оценка
    print("\n--- Оценка модели на тестовых данных ---")
    y_pred = voting_ensemble.predict(X_test)
    y_proba = voting_ensemble.predict_proba(X_test)[:, 1]

    print("Отчет по классификации:")
    print(classification_report(y_test, y_pred))
    print(f"Accuracy: {accuracy_score(y_test, y_pred):.4f}")
    print(f"F1-score: {f1_score(y_test, y_pred):.4f}")
    print(f"ROC-AUC: {roc_auc_score(y_test, y_proba):.4f}")

    # Сохранение артефактов
    save_artifacts(voting_ensemble, y_test, y_pred, y_proba, period_type)

def save_artifacts(model, y_test, y_pred, y_proba, period_type):
    """Сохраняет модель и графики."""
    if not os.path.exists(OUTPUT_MODEL_DIR):
        os.makedirs(OUTPUT_MODEL_DIR)

    # Сохранение модели
    model_path = os.path.join(OUTPUT_MODEL_DIR, f'model_{period_type}.pkl')
    joblib.dump(model, model_path)
    print(f"\nМодель сохранена в: {model_path}")

    # Матрица ошибок
    plt.figure(figsize=(6, 6))
    cm = confusion_matrix(y_test, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Greens',
                xticklabels=['Нет вегетации', 'Вегетация'],
                yticklabels=['Нет вегетации', 'Вегетация'])
    plt.xlabel("Предсказанные значения")
    plt.ylabel("Истинные значения")
    plt.title(f"Матрица ошибок ({period_type.capitalize()} Period)")
    plt.savefig(os.path.join(OUTPUT_MODEL_DIR, f'confusion_matrix_{period_type}.png'))
    plt.close()
    print(f"Матрица ошибок сохранена.")

    # ROC-кривая
    fpr, tpr, _ = roc_curve(y_test, y_proba)
    roc_auc = auc(fpr, tpr)
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC-кривая (AUC = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title(f'ROC-кривая ({period_type.capitalize()} Period)')
    plt.legend(loc="lower right")
    plt.grid(True)
    plt.savefig(os.path.join(OUTPUT_MODEL_DIR, f'roc_curve_{period_type}.png'))
    plt.close()
    print(f"ROC-кривая сохранена.")


# --- Основной блок для запуска скрипта ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Обучение модели для определения периода вегетации.")
    parser.add_argument(
        '--period_type',
        type=str,
        choices=['start', 'end'],
        required=True,
        help="Тип периода для обучения: 'start' (начало) или 'end' (конец)."
    )
    args = parser.parse_args()

    X, y = load_and_prepare_data(args.period_type)
    train_and_evaluate(X, y, args.period_type)